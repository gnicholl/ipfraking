% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/raking-wt.r
\name{raking}
\alias{raking}
\title{Survey Raking in R}
\usage{
raking(
  formula,
  data,
  targets,
  namesTotals,
  maxiter = 50,
  epsilon = 1,
  freq = TRUE,
  freqWarn = 15,
  verbose = c("some", "none", "full"),
  trim = FALSE,
  trim.method = c("median", "mean"),
  trim.max = 6,
  trim.lim = c(0, trim.max),
  trim.group = NULL,
  cutoff.above = NULL,
  cutoff.below = NULL,
  ...
)
}
\arguments{
\item{formula}{a formula object, with the input/start weights on the left of the ~ operator and the raking variables on the right, with each raking variable separated by the + operator. Two-way variable raking can be done by using the * operator.}

\item{data}{data frame of respondents in which to interpret the variables named in the formula.}

\item{targets}{a single data frame or a list of data frames containing the target/calibration totals/figures. The raking variables listed in the formula must match the column names of those data frames. The target data frames must be listed in the same order as their corresponding raking variables in the formula.}

\item{namesTotals}{the name of the column that contains the target/calibration totals in each data frame listed in targets.}

\item{maxiter}{(default 50) maximum number of iterations to attempt for convergence.}

\item{epsilon}{(default 1) convergence is declared if the maximum of the differences between marginal total of the raked weights and the target/calibration totals is less than or equal to epsilon. If epsilon<1 it is taken to be a fraction of the total of the input/start weights in the formula.}

\item{freq}{Logical. If true (default), frequency tables are displayed (this is useful to see if cells should be collapsed).}

\item{freqWarn}{a warning message will be displayed if one or more cells contained fewer than this number (default 15) of observations.}

\item{verbose}{controls the amount of output displayed on the screen.}

\item{trim}{logical, if true large weights will be trimmed. This is done using a technique very similar to the IGCV method of Izrael et al. (2009)}

\item{trim.method}{"median" (default) or "mean"; see trim.max}

\item{trim.max}{(default 6) each weight w is trimmed if w > trim.max * trim.method(weights)}

\item{trim.lim}{(default c(0,trim.max)) each weight is trimmed if w > trim.lim\link{2} \* trim.method(weights) or w < trim.lim\link{1} \* trim.method(weights)}

\item{trim.group}{if NULL (default), the overall mean/median of the weights is used when trimming; if trim.group is the name of a column of data, then the weights will be trimmed based on which group of trim.group they belong to.}

\item{cutoff.above}{A function that takes one argument (a vector of weights) and produces a single number representing the desired upper bound for weight trimming. If \code{cutoff.above} or \code{cutoff.below} is specified, arguments \code{trim.method}, \code{trim.max}, \code{trim.lim} are ignored.}

\item{cutoff.below}{A function that takes one argument (a vector of weights) and produces a single number representing the desired lower bound for weight trimming. If \code{cutoff.above} or \code{cutoff.below} is specified, arguments \code{trim.method}, \code{trim.max}, \code{trim.lim} are ignored.}
}
\description{
Performs raking of survey weights, using a technique very similar to the SAS IHB Macro
}
\examples{
# Packages
library(PracTools)
library(sampling)
library(dplyr)

# Population data
data(MDarea.popA)
MDarea.pop = MDarea.popA

# population counts for two strata variables
table(MDarea.pop$BLKGROUP, MDarea.pop$Gender)

# take a randomly stratified sample based on BLKGROUP and Gender
set.seed(20230128)
sample = sampling::strata(
  data=MDarea.pop,
  stratanames=c("BLKGROUP","Gender"),
  size=sample(30:100, size=12, replace=TRUE),
  method="srswor"
)

#### example 1: rake only on Gender
# population totals
targets_Gender = data.frame(
  Gender=1:2,
  popcount=as.numeric(table(MDarea.pop$Gender)))

# initial weights
sample_ex1 = sample \%>\%
  mutate(wgt.init = 1)

# raking
rake_ex1 = raking(
  wgt.init ~ Gender,
  data=sample_ex1,
  targets=list(targets_Gender),
  namesTotals="popcount"
)
sample_ex1$wgt.rake = rake_ex1$weights
# check that sum of weights match population targets
sample_ex1 \%>\%
  group_by(Gender) \%>\%
  summarise(wgttotals = sum(wgt.rake))



#### example 2: rake on Gender and Geographic area using marginal totals
# population totals
targets_Gender = data.frame(
  Gender=1:2,
  popcount=as.numeric(table(MDarea.pop$Gender)))
targets_BLKGRP = data.frame(
  BLKGROUP=1:6,
  popcount=as.numeric(table(MDarea.pop$BLKGROUP)))

# initial weights
sample_ex2 = sample \%>\%
  mutate(wgt.init = 1)

# raking
rake_ex2 = raking(
  wgt.init ~ Gender + BLKGROUP,
  data=sample_ex2,
  targets=list(targets_Gender, targets_BLKGRP),
  namesTotals="popcount"
)
sample_ex2$wgt.rake = rake_ex2$weights

# check that sum of weights match population targets
sample_ex2 \%>\%
  group_by(Gender) \%>\%
  summarise(wgttotals = sum(wgt.rake))
sample_ex2 \%>\%
  group_by(BLKGROUP) \%>\%
  summarise(wgttotals = sum(wgt.rake))



#### example 3: rake on all Gender-GeographicArea bins
# (equivalent to post-stratification)
# population totals
targets_GenderBLK = as.data.frame(table(MDarea.pop$BLKGROUP, MDarea.pop$Gender)) \%>\%
  rename(BLKGROUP = Var1,
         Gender   = Var2,
         popcount = Freq)

# initial weights
sample_ex3 = sample \%>\%
  mutate(wgt.init = 1)

# raking
rake_ex3 = raking(
  wgt.init ~ Gender*BLKGROUP,
  data=sample_ex3,
  targets=list(targets_GenderBLK),
  namesTotals="popcount"
)
sample_ex3$wgt.rake = rake_ex3$weights

# check that sum of weights match population targets
sample_ex3 \%>\%
  group_by(Gender,BLKGROUP) \%>\%
  summarise(wgttotals = sum(wgt.rake))



#### example 4: two ways to trim
# initial weights
sample_ex4 = sample
set.seed(20230128)
sample_ex4$wgt.init = rchisq(nrow(sample),df=10)

# method 1: specify trim.method and trim.lim
rake_ex4a = raking_test(
  wgt.init ~ Gender + BLKGROUP,
  data=sample_ex4,
  targets=list(targets_Gender, targets_BLKGRP),
  namesTotals="popcount",
  trim.method="median",
  trim.lim=c(0.0025,4.5),
  trim=TRUE,
  trim.group="Gender"
)

# method 2: specify cutoff.above and cutoff.below
rake_ex4b = raking_test(
  wgt.init ~ Gender + BLKGROUP,
  data=sample_ex4,
  targets=list(targets_Gender, targets_BLKGRP),
  namesTotals="popcount",
  trim=TRUE,
  trim.group="Gender",
  cutoff.above = function(w) return(4.5*median(w)),
  cutoff.below = function(w) return(0.0025*median(w))
)

# check that method 1 and 2 equivalent
all(rake_ex4a$weights==rake_ex4b$weights)

# method 2 allows more than just mean and median:
rake_ex4c = raking_test(
  wgt.init ~ Gender + BLKGROUP,
  data=sample_ex4,
  targets=list(targets_Gender, targets_BLKGRP),
  namesTotals="popcount",
  trim=TRUE,
  trim.group="Gender",
  cutoff.above = function(w) quantile(w, probs=0.75, names=FALSE) + 1.5*IQR(w)
)
}
\references{
\itemize{
\item Izrael, Hoaglin & Battaglia (2000), \href{http://www2.sas.com/proceedings/sugi25/25/st/25p258.pdf}{"A SAS Macro for Balancing a Weighted Sample"}, Proceedings of the 25th Annual SAS Users Group International Conference, Paper 258
\item Izrael, Battaglia & Frankel (2009), \href{https://support.sas.com/resources/papers/proceedings09/247-2009.pdf}{"Extreme Survey Weight Adjustment as a Component of Sample Balancing (a.k.a. Raking)"}, SAS Global Forum, Paper 247-2009
}
}
